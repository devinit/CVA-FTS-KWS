# desired_order <- col_order$column_name
# Reorder the columns of the inverted file
inverted_ordered <- inverted %>% select(all_of(desired_order))
View(inverted_ordered)
# Load necessary libraries
library(readxl)
library(dplyr)
library(openxlsx) # For writing the output file
# Specify file paths
col_order_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/col_order.xlsx"
inverted_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/inverted.xlsx"
output_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/uninverted.xlsx" # Specify where you want to save the output
# Read the Excel files
col_order <- read_excel(col_order_file)
inverted <- read_excel(inverted_file)
# Extract the desired column order
# Assuming col_order is a single row with column names
desired_order <- colnames(col_order)
# If col_order is a single column with column names, use the following line instead:
# desired_order <- col_order$column_name
# Reorder the columns of the inverted file
inverted_ordered <- inverted %>% select(all_of(desired_order))
# Load necessary libraries
library(readxl)
library(dplyr)
library(openxlsx) # For writing the output file
# Specify file paths
col_order_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/col_order.xlsx"
inverted_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/inverted.xlsx"
output_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/uninverted.xlsx" # Specify where you want to save the output
# Read the Excel files
col_order <- read_excel(col_order_file)
inverted <- read_excel(inverted_file)
# Extract the desired column order
# Assuming col_order is a single row with column names
desired_order <- colnames(col_order)
# If col_order is a single column with column names, use the following line instead:
# desired_order <- col_order$column_name
# Reorder the columns of the inverted file
inverted_ordered <- inverted %>% select(all_of(desired_order))
missing_in_inverted <- setdiff(col_order_names, inverted_names)
col_order_names <- colnames(col_order)
# If col_order is a single column with column names, use this line instead:
# col_order_names <- col_order$column_name
inverted_names <- colnames(inverted)
# Identify columns in col_order but not in inverted
missing_in_inverted <- setdiff(col_order_names, inverted_names)
# Load necessary libraries
library(readxl)
library(dplyr)
library(openxlsx) # For writing the output file
# Specify file paths
col_order_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/col_order.xlsx"
inverted_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/inverted.xlsx"
output_file <- "C:/Users/mike.pearson/OneDrive - Development Initiatives Poverty Research Limited/Desktop/uninverted.xlsx" # Specify where you want to save the output
# Read the Excel files
col_order <- read_excel(col_order_file)
inverted <- read_excel(inverted_file)
# Extract the desired column order
# Assuming col_order is a single row with column names
desired_order <- colnames(col_order)
# If col_order is a single column with column names, use the following line instead:
# desired_order <- col_order$column_name
# Reorder the columns of the inverted file
inverted_ordered <- inverted %>% select(all_of(desired_order))
# Save the reordered data frame back to an Excel file
write.xlsx(inverted_ordered, output_file)
# Print a message indicating success
cat("The inverted file has been reordered and saved as", output_file, "\n")
suppressPackageStartupMessages(lapply(c("data.table", "jsonlite","rstudioapi"), require, character.only=T))
##load in fts
years <- 2017:2024
fts_curated <- list()
for (i in 1:length(years)){
year <- years[i]
fts_curated[[i]] <- fread(paste0("https://raw.githubusercontent.com/devinit/gha_automation/main/IHA/datasets/fts_curated_master/fts_curated_",year,".csv"))
message(year)
}
fts <- rbindlist(fts_curated, use.names=T)
fts <- fts[as.character(year) >= 2017]
project_metadata = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/projects/cash_projects.csv")
project_metadata$project_id = as.character(project_metadata$project_id)
project_text = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/projects/project_text.csv")
project_text$text = paste(project_text$project_name, project_text$project_objective)
project_text[,c("project_name", "project_objective")] = NULL
project_data = merge(project_text, project_metadata, all=T)
names(project_data) = c("sourceObjects_Project.id", "project_text", "project_cva_percentage", "project_cva")
setdiff(unique(fts$sourceObjects_Project.id), unique(project_data$sourceObjects_Project.id))
## Maybe add in keep function to have only required columns
fts$sourceObjects_Project.id = as.character(fts$sourceObjects_Project.id)
fts = merge(fts, project_data, by="sourceObjects_Project.id", all.x=T)
fts$all_text = paste(fts$description, fts$project_text)
##Keywords from Nik's keyword list, can we tweak so acroynms only picked up if standalone?
#keywords are not case sensitive
cash.noncase.keywords <- c(
"cash",
"voucher",
"cash transfer",
"cash grant",
"unconditional cash",
"money",
"conditional cash transfer",
"argent",
"monetaires",
"bons",
"espèces",
"monnaie",
"monétaires",
"monétaire",
"tokens",
"coupons",
"cupones",
"public works programme",
"social assistance",
"social safety net",
"social transfer",
"social protection"
)
#acronyms are case-sensitive
cash.acronyms <- c(
"CCT",
"UCT",
"CTP",
"CFW",
"CFA",
"SSN",
"ESSN",
"MPC",
"MPCT",
"CVA"
)
cash_regex = paste0(
"\\b",
paste(c(tolower(cash.noncase.keywords), tolower(cash.acronyms)), collapse="\\b|\\b"),
"\\b"
)
##Relevant clusters from cluster mapping
cash_clusters <- c(
"Basic Needs / Multi-Purpose Cash",
"Cash à usage multiple",
"Multi Purpose Cash",
"Multi-cluster/Multi-Purpose Cash",
"Multi-Purpose Cash & Social Protection",
"Multipurpose Cash Assistance (MPC)",
"Multi-Purpose Cash Assistance (MPCA)",
"Multipurpose cash/ IDPs/ multisector",
"Multi-sector Cash/Social Protection COVID-19",
"Cash",
"Multi-purpose Cash",
"Multipurpose cash assistance",
"Multi-Purpose Cash Assistance",
"Multipurpose Cash Assistance COVID-19",
"Multi-Purpose Cash Assistance COVID-19",
"Multi-purpose Cash COVID-19",
"Multipurpose cash",
"Protection: Multi-Purpose Cash Assistance",
"Cash Transfer COVID-19"
)
fts$sector_method_cluster_relevance <- "None"
## Define relevance based on sector and/or method
fts[method == "Cash transfer programming (CTP)", sector_method_cluster_relevance := "Full"]
fts[destinationObjects_Cluster.name %in% cash_clusters, sector_method_cluster_relevance := "Full"]
#TODO select partial sectors with cash cluster and
fts[grepl(";", destinationObjects_Cluster.name) == T & grepl(paste0(cash_clusters, collapse = "|"), destinationObjects_Cluster.name), sector_method_cluster_relevance := "Partial"]
## was by use of grepl | and if cash_clusters == T??
#Count number of keywords appearing in description
fts$keyword_match = grepl(cash_regex, fts$all_text, ignore.case=T)
mean(fts$keyword_match > 0)
##below checks where relevance is none and there are or are not keywords
##second line below useful for identifying new keywords maybe missing
View(fts[sector_method_cluster_relevance == "None" & keyword_match][,"all_text"])
View(fts[sector_method_cluster_relevance != "None" & !keyword_match][,"all_text"])
# Start with sector/method/cluster relevance
fts$relevance = fts$sector_method_cluster_relevance
fts$relevance_method = "Sector/Method/Cluster"
# If percentage is greater than or equal to 0.75, mark full
fts$relevance_method[which(fts$project_cva_percentage >= 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage >= 0.75)] = "Full"
# If percentage is greater than 0 but less than 0.75, mark partial
fts$relevance_method[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Partial"
# Save those that are either keyword match or marked at project level as CVA, but are None for ML
# to_inference = subset(fts, (keyword_match | project_cva) & relevance == "None")
# keep = c("id", "description")
# to_inference = unique(to_inference[,keep,with=F])
# setnames(to_inference, "description", "text")
# fwrite(to_inference, "classifier_code/fts_to_inference.csv")
# Load and join inferenced data
inference_output = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/classifier_code/fts_to_inference_output.csv")
mean(inference_output$predicted_class=="Full")
hist(inference_output$predicted_confidence)
inference_output$text = NULL
fts = merge(fts, inference_output, by="id", all.x=T)
# Change Partial relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Partial"
# Change Full relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Full")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Full")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Full")] = "Full"
fts_flagged <- fts[
which(
fts$relevance != "None"
)
]
table(fts$relevance)
table(fts_flagged$relevance_method)
fts_flagged$all_text = NULL
suppressPackageStartupMessages(lapply(c("data.table", "jsonlite","rstudioapi"), require, character.only=T))
##load in fts
years <- 2017:2024
fts_curated <- list()
for (i in 1:length(years)){
year <- years[i]
fts_curated[[i]] <- fread(paste0("https://raw.githubusercontent.com/devinit/gha_automation/main/IHA/datasets/fts_curated_master/fts_curated_",year,".csv"))
message(year)
}
fts <- rbindlist(fts_curated, use.names=T)
fts <- fts[as.character(year) >= 2017]
project_metadata = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/projects/cash_projects.csv")
project_metadata$project_id = as.character(project_metadata$project_id)
project_text = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/projects/project_text.csv")
project_text$text = paste(project_text$project_name, project_text$project_objective)
project_text[,c("project_name", "project_objective")] = NULL
project_data = merge(project_text, project_metadata, all=T)
names(project_data) = c("destinationObjects_Project.id", "project_text", "project_cva_percentage", "project_cva")
setdiff(unique(fts$destinationObjects_Project.id), unique(project_data$destinationObjects_Project.id))
## Maybe add in keep function to have only required columns
fts$destinationObjects_Project.id = as.character(fts$destinationObjects_Project.id)
fts = merge(fts, project_data, by="destinationObjects_Project.id", all.x=T)
fts$all_text = paste(fts$description, fts$project_text)
##Keywords from Nik's keyword list, can we tweak so acroynms only picked up if standalone?
#keywords are not case sensitive
cash.noncase.keywords <- c(
"cash",
"voucher",
"cash transfer",
"cash grant",
"unconditional cash",
"money",
"conditional cash transfer",
"argent",
"monetaires",
"bons",
"espèces",
"monnaie",
"monétaires",
"monétaire",
"tokens",
"coupons",
"cupones",
"public works programme",
"social assistance",
"social safety net",
"social transfer",
"social protection"
)
#acronyms are case-sensitive
cash.acronyms <- c(
"CCT",
"UCT",
"CTP",
"CFW",
"CFA",
"SSN",
"ESSN",
"MPC",
"MPCT",
"CVA"
)
cash_regex = paste0(
"\\b",
paste(c(tolower(cash.noncase.keywords), tolower(cash.acronyms)), collapse="\\b|\\b"),
"\\b"
)
##Relevant clusters from cluster mapping
cash_clusters <- c(
"Basic Needs / Multi-Purpose Cash",
"Cash à usage multiple",
"Multi Purpose Cash",
"Multi-cluster/Multi-Purpose Cash",
"Multi-Purpose Cash & Social Protection",
"Multipurpose Cash Assistance (MPC)",
"Multi-Purpose Cash Assistance (MPCA)",
"Multipurpose cash/ IDPs/ multisector",
"Multi-sector Cash/Social Protection COVID-19",
"Cash",
"Multi-purpose Cash",
"Multipurpose cash assistance",
"Multi-Purpose Cash Assistance",
"Multipurpose Cash Assistance COVID-19",
"Multi-Purpose Cash Assistance COVID-19",
"Multi-purpose Cash COVID-19",
"Multipurpose cash",
"Protection: Multi-Purpose Cash Assistance",
"Cash Transfer COVID-19"
)
fts$sector_method_cluster_relevance <- "None"
## Define relevance based on sector and/or method
fts[method == "Cash transfer programming (CTP)", sector_method_cluster_relevance := "Full"]
fts[destinationObjects_Cluster.name %in% cash_clusters, sector_method_cluster_relevance := "Full"]
#TODO select partial sectors with cash cluster and
fts[grepl(";", destinationObjects_Cluster.name) == T & grepl(paste0(cash_clusters, collapse = "|"), destinationObjects_Cluster.name), sector_method_cluster_relevance := "Partial"]
## was by use of grepl | and if cash_clusters == T??
#Count number of keywords appearing in description
fts$keyword_match = grepl(cash_regex, fts$all_text, ignore.case=T)
mean(fts$keyword_match > 0)
##below checks where relevance is none and there are or are not keywords
##second line below useful for identifying new keywords maybe missing
View(fts[sector_method_cluster_relevance == "None" & keyword_match][,"all_text"])
View(fts[sector_method_cluster_relevance != "None" & !keyword_match][,"all_text"])
# Start with sector/method/cluster relevance
fts$relevance = fts$sector_method_cluster_relevance
fts$relevance_method = "Sector/Method/Cluster"
# If percentage is greater than or equal to 0.75, mark full
fts$relevance_method[which(fts$project_cva_percentage >= 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage >= 0.75)] = "Full"
# If percentage is greater than 0 but less than 0.75, mark partial
fts$relevance_method[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Partial"
# Save those that are either keyword match or marked at project level as CVA, but are None for ML
# to_inference = subset(fts, (keyword_match | project_cva) & relevance == "None")
# keep = c("id", "description")
# to_inference = unique(to_inference[,keep,with=F])
# setnames(to_inference, "description", "text")
# fwrite(to_inference, "classifier_code/fts_to_inference.csv")
# Load and join inferenced data
inference_output = fread("https://raw.githubusercontent.com/devinit/CVA-FTS-KWS/main/classifier_code/fts_to_inference_output.csv")
mean(inference_output$predicted_class=="Full")
hist(inference_output$predicted_confidence)
inference_output$text = NULL
fts = merge(fts, inference_output, by="id", all.x=T)
# Change Partial relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Partial"
# Change Full relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Full")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Full")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Full")] = "Full"
fts_flagged_1 <- fts[
which(
fts$relevance != "None"
)
]
table(fts$relevance)
table(fts_flagged_1$relevance_method)
fts_flagged_1$all_text = NULL
View(fts_flagged_1)
fts_flagged_1a <- fts_flagged_1
fts_flagged_1a <- fts_flagged_1a[!is.na(fts_flagged_1a$destinationObjects_Project.id),]
View(fts_flagged_1a)
View(fts_flagged_1a)
setdiff(unique(fts$destinationObjects_Project.id), unique(project_data$destinationObjects_Project.id))
View(fts_flagged_1a)
setdiff(unique(fts_flagged$id), unique(fts_flagged_1$id))
setdiff(unique(fts_flagged_1$id), unique(fts_flagged$id))
View(fts_flagged_1)
test <- fts_flagged_1a[fts_flagged_1a$id == 157920]
View(test)
View(project_data)
View(fts)
suppressPackageStartupMessages(lapply(c("data.table", "jsonlite","rstudioapi"), require, character.only=T))
setwd(dirname(getActiveDocumentContext()$path))
##load in fts
years <- 2017:2024
fts_curated <- list()
for (i in 1:length(years)){
year <- years[i]
fts_curated[[i]] <- fread(paste0("https://raw.githubusercontent.com/devinit/gha_automation/main/IHA/datasets/fts_curated_master/fts_curated_",year,".csv"))
message(year)
}
fts <- rbindlist(fts_curated, use.names=T)
fts <- fts[as.character(year) >= 2017]
# Load in project data
project_metadata = fread("projects/cash_projects.csv")
project_metadata$project_id = as.character(project_metadata$project_id)
project_text = fread("projects/project_text.csv")
project_text$text = paste(project_text$project_name, project_text$project_objective)
project_text[,c("project_name", "project_objective")] = NULL
project_data = merge(project_text, project_metadata, all=T)
names(project_data) = c("destinationObjects_Project.id", "project_text", "project_cva_percentage", "project_cva")
setdiff(unique(fts$destinationObjects_Project.id), unique(project_data$destinationObjects_Project.id))
## Maybe add in keep function to have only required columns
fts$destinationObjects_Project.id = as.character(fts$destinationObjects_Project.id)
fts = merge(fts, project_data, by="destinationObjects_Project.id", all.x=T)
fts$all_text = paste(fts$description, fts$project_text)
##Keywords from Nik's keyword list, can we tweak so acroynms only picked up if standalone?
#keywords are not case sensitive
cash.noncase.keywords <- c(
"cash",
"voucher",
"cash transfer",
"cash grant",
"unconditional cash",
"money",
"conditional cash transfer",
"argent",
"monetaires",
"bons",
"espèces",
"monnaie",
"monétaires",
"monétaire",
"tokens",
"coupons",
"cupones",
"public works programme",
"social assistance",
"social safety net",
"social transfer",
"social protection"
)
#acronyms are case-sensitive
cash.acronyms <- c(
"CCT",
"UCT",
"CTP",
"CFW",
"CFA",
"SSN",
"ESSN",
"MPC",
"MPCT",
"CVA"
)
cash_regex = paste0(
"\\b",
paste(c(tolower(cash.noncase.keywords), tolower(cash.acronyms)), collapse="\\b|\\b"),
"\\b"
)
##Relevant clusters from cluster mapping
cash_clusters <- c(
"Basic Needs / Multi-Purpose Cash",
"Cash à usage multiple",
"Multi Purpose Cash",
"Multi-cluster/Multi-Purpose Cash",
"Multi-Purpose Cash & Social Protection",
"Multipurpose Cash Assistance (MPC)",
"Multi-Purpose Cash Assistance (MPCA)",
"Multipurpose cash/ IDPs/ multisector",
"Multi-sector Cash/Social Protection COVID-19",
"Cash",
"Multi-purpose Cash",
"Multipurpose cash assistance",
"Multi-Purpose Cash Assistance",
"Multipurpose Cash Assistance COVID-19",
"Multi-Purpose Cash Assistance COVID-19",
"Multi-purpose Cash COVID-19",
"Multipurpose cash",
"Protection: Multi-Purpose Cash Assistance",
"Cash Transfer COVID-19"
)
fts$sector_method_cluster_relevance <- "None"
## Define relevance based on sector and/or method
fts[method == "Cash transfer programming (CTP)", sector_method_cluster_relevance := "Full"]
fts[destinationObjects_Cluster.name %in% cash_clusters, sector_method_cluster_relevance := "Full"]
#TODO select partial sectors with cash cluster and
fts[grepl(";", destinationObjects_Cluster.name) == T & grepl(paste0(cash_clusters, collapse = "|"), destinationObjects_Cluster.name), sector_method_cluster_relevance := "Partial"]
## was by use of grepl | and if cash_clusters == T??
#Count number of keywords appearing in description
fts$keyword_match = grepl(cash_regex, fts$all_text, ignore.case=T)
mean(fts$keyword_match > 0)
##below checks where relevance is none and there are or are not keywords
##second line below useful for identifying new keywords maybe missing
View(fts[sector_method_cluster_relevance == "None" & keyword_match][,"all_text"])
View(fts[sector_method_cluster_relevance != "None" & !keyword_match][,"all_text"])
# Start with sector/method/cluster relevance
fts$relevance = fts$sector_method_cluster_relevance
fts$relevance_method = "Sector/Method/Cluster"
# If percentage is greater than or equal to 0.75, mark full
fts$relevance_method[which(fts$project_cva_percentage >= 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage >= 0.75)] = "Full"
# If percentage is greater than 0 but less than 0.75, mark partial
fts$relevance_method[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Project CVA Percentage"
fts$relevance[which(fts$project_cva_percentage > 0 & fts$project_cva_percentage < 0.75)] = "Partial"
# Save those that are either keyword match or marked at project level as CVA, but are None for ML
# to_inference = subset(fts, (keyword_match | project_cva) & relevance == "None")
# keep = c("id", "description")
# to_inference = unique(to_inference[,keep,with=F])
# setnames(to_inference, "description", "text")
# fwrite(to_inference, "classifier_code/fts_to_inference.csv")
# Load and join inferenced data
inference_output = fread("classifier_code/fts_to_inference_output.csv")
mean(inference_output$predicted_class=="Full")
hist(inference_output$predicted_confidence)
inference_output$text = NULL
fts = merge(fts, inference_output, by="id", all.x=T)
# Change Partial relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Partial")] = "Partial"
# Change Full relevance by ML
fts$relevance_method[which(fts$keyword_match & fts$relevance == "None" & fts$predicted_class=="Full")] = "Keyword + ML"
fts$relevance_method[which(fts$project_cva & fts$relevance == "None" & fts$predicted_class=="Full")] = "Project API + ML"
fts$relevance[which((fts$keyword_match | fts$project_cva) & fts$relevance == "None" & fts$predicted_class=="Full")] = "Full"
fts_flagged <- fts[
which(
fts$relevance != "None"
)
]
table(fts$relevance)
table(fts_flagged$relevance_method)
fts_flagged$all_text = NULL
fwrite(fts_flagged, "fts_output_CVA.csv")
#
View(fts)
fts1 <- fts[fts$id == 157813]
View(fts1)
View(fts1)
View(fts)
